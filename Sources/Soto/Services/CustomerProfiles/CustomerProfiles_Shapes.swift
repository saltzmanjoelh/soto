//===----------------------------------------------------------------------===//
//
// This source file is part of the Soto for AWS open source project
//
// Copyright (c) 2017-2021 the Soto project authors
// Licensed under Apache License v2.0
//
// See LICENSE.txt for license information
// See CONTRIBUTORS.txt for the list of Soto project authors
//
// SPDX-License-Identifier: Apache-2.0
//
//===----------------------------------------------------------------------===//

// THIS FILE IS AUTOMATICALLY GENERATED by https://github.com/soto-project/soto/tree/main/CodeGenerator. DO NOT EDIT.

import Foundation
import SotoCore

extension CustomerProfiles {
    // MARK: Enums

    public enum DataPullMode: String, CustomStringConvertible, Codable {
        case complete = "Complete"
        case incremental = "Incremental"
        public var description: String { return self.rawValue }
    }

    public enum FieldContentType: String, CustomStringConvertible, Codable {
        case emailAddress = "EMAIL_ADDRESS"
        case name = "NAME"
        case number = "NUMBER"
        case phoneNumber = "PHONE_NUMBER"
        case string = "STRING"
        public var description: String { return self.rawValue }
    }

    public enum Gender: String, CustomStringConvertible, Codable {
        case female = "FEMALE"
        case male = "MALE"
        case unspecified = "UNSPECIFIED"
        public var description: String { return self.rawValue }
    }

    public enum MarketoConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case division = "DIVISION"
        case greaterThan = "GREATER_THAN"
        case lessThan = "LESS_THAN"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum OperatorPropertiesKeys: String, CustomStringConvertible, Codable {
        case concatFormat = "CONCAT_FORMAT"
        case dataType = "DATA_TYPE"
        case destinationDataType = "DESTINATION_DATA_TYPE"
        case lowerBound = "LOWER_BOUND"
        case maskLength = "MASK_LENGTH"
        case maskValue = "MASK_VALUE"
        case mathOperationFieldsOrder = "MATH_OPERATION_FIELDS_ORDER"
        case sourceDataType = "SOURCE_DATA_TYPE"
        case subfieldCategoryMap = "SUBFIELD_CATEGORY_MAP"
        case truncateLength = "TRUNCATE_LENGTH"
        case upperBound = "UPPER_BOUND"
        case validationAction = "VALIDATION_ACTION"
        case value = "VALUE"
        case values = "VALUES"
        public var description: String { return self.rawValue }
    }

    public enum PartyType: String, CustomStringConvertible, Codable {
        case business = "BUSINESS"
        case individual = "INDIVIDUAL"
        case other = "OTHER"
        public var description: String { return self.rawValue }
    }

    public enum S3ConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum SalesforceConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum ServiceNowConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case between = "BETWEEN"
        case contains = "CONTAINS"
        case division = "DIVISION"
        case equalTo = "EQUAL_TO"
        case greaterThan = "GREATER_THAN"
        case greaterThanOrEqualTo = "GREATER_THAN_OR_EQUAL_TO"
        case lessThan = "LESS_THAN"
        case lessThanOrEqualTo = "LESS_THAN_OR_EQUAL_TO"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case notEqualTo = "NOT_EQUAL_TO"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    public enum SourceConnectorType: String, CustomStringConvertible, Codable {
        case marketo = "Marketo"
        case s3 = "S3"
        case salesforce = "Salesforce"
        case servicenow = "Servicenow"
        case zendesk = "Zendesk"
        public var description: String { return self.rawValue }
    }

    public enum StandardIdentifier: String, CustomStringConvertible, Codable {
        case lookupOnly = "LOOKUP_ONLY"
        case newOnly = "NEW_ONLY"
        case profile = "PROFILE"
        case secondary = "SECONDARY"
        case unique = "UNIQUE"
        public var description: String { return self.rawValue }
    }

    public enum TaskType: String, CustomStringConvertible, Codable {
        case arithmetic = "Arithmetic"
        case filter = "Filter"
        case map = "Map"
        case mask = "Mask"
        case merge = "Merge"
        case truncate = "Truncate"
        case validate = "Validate"
        public var description: String { return self.rawValue }
    }

    public enum TriggerType: String, CustomStringConvertible, Codable {
        case event = "Event"
        case ondemand = "OnDemand"
        case scheduled = "Scheduled"
        public var description: String { return self.rawValue }
    }

    public enum ZendeskConnectorOperator: String, CustomStringConvertible, Codable {
        case addition = "ADDITION"
        case division = "DIVISION"
        case greaterThan = "GREATER_THAN"
        case maskAll = "MASK_ALL"
        case maskFirstN = "MASK_FIRST_N"
        case maskLastN = "MASK_LAST_N"
        case multiplication = "MULTIPLICATION"
        case noOp = "NO_OP"
        case projection = "PROJECTION"
        case subtraction = "SUBTRACTION"
        case validateNonNegative = "VALIDATE_NON_NEGATIVE"
        case validateNonNull = "VALIDATE_NON_NULL"
        case validateNonZero = "VALIDATE_NON_ZERO"
        case validateNumeric = "VALIDATE_NUMERIC"
        public var description: String { return self.rawValue }
    }

    // MARK: Shapes

    public struct AddProfileKeyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// The unique name of the domain.
        public let domainName: String
        /// A searchable identifier of a customer profile.
        public let keyName: String
        /// The unique identifier of a customer profile.
        public let profileId: String
        /// A list of key values.
        public let values: [String]

        public init(domainName: String, keyName: String, profileId: String, values: [String]) {
            self.domainName = domainName
            self.keyName = keyName
            self.profileId = profileId
            self.values = values
        }

        public func validate(name: String) throws {
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.keyName.forEach {}
            try self.validate(self.keyName, name: "keyName", parent: name, max: 64)
            try self.validate(self.keyName, name: "keyName", parent: name, min: 1)
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.profileId.forEach {}
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "[a-f0-9]{32}")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.values.forEach {}
        }

        private enum CodingKeys: String, CodingKey {
            case keyName = "KeyName"
            case profileId = "ProfileId"
            case values = "Values"
        }
    }

    public struct AddProfileKeyResponse: AWSDecodableShape {
        /// A searchable identifier of a customer profile.
        public let keyName: String?
        /// A list of key values.
        public let values: [String]?

        public init(keyName: String? = nil, values: [String]? = nil) {
            self.keyName = keyName
            self.values = values
        }

        private enum CodingKeys: String, CodingKey {
            case keyName = "KeyName"
            case values = "Values"
        }
    }

    public struct Address: AWSEncodableShape & AWSDecodableShape {
        /// The first line of a customer address.
        public let address1: String?
        /// The second line of a customer address.
        public let address2: String?
        /// The third line of a customer address.
        public let address3: String?
        /// The fourth line of a customer address.
        public let address4: String?
        /// The city in which a customer lives.
        public let city: String?
        /// The country in which a customer lives.
        public let country: String?
        /// The county in which a customer lives.
        public let county: String?
        /// The postal code of a customer address.
        public let postalCode: String?
        /// The province in which a customer lives.
        public let province: String?
        /// The state in which a customer lives.
        public let state: String?

        public init(address1: String? = nil, address2: String? = nil, address3: String? = nil, address4: String? = nil, city: String? = nil, country: String? = nil, county: String? = nil, postalCode: String? = nil, province: String? = nil, state: String? = nil) {
            self.address1 = address1
            self.address2 = address2
            self.address3 = address3
            self.address4 = address4
            self.city = city
            self.country = country
            self.county = county
            self.postalCode = postalCode
            self.province = province
            self.state = state
        }

        public func validate(name: String) throws {
            try self.address1?.forEach {}
            try self.validate(self.address1, name: "address1", parent: name, max: 255)
            try self.validate(self.address1, name: "address1", parent: name, min: 1)
            try self.address2?.forEach {}
            try self.validate(self.address2, name: "address2", parent: name, max: 255)
            try self.validate(self.address2, name: "address2", parent: name, min: 1)
            try self.address3?.forEach {}
            try self.validate(self.address3, name: "address3", parent: name, max: 255)
            try self.validate(self.address3, name: "address3", parent: name, min: 1)
            try self.address4?.forEach {}
            try self.validate(self.address4, name: "address4", parent: name, max: 255)
            try self.validate(self.address4, name: "address4", parent: name, min: 1)
            try self.city?.forEach {}
            try self.validate(self.city, name: "city", parent: name, max: 255)
            try self.validate(self.city, name: "city", parent: name, min: 1)
            try self.country?.forEach {}
            try self.validate(self.country, name: "country", parent: name, max: 255)
            try self.validate(self.country, name: "country", parent: name, min: 1)
            try self.county?.forEach {}
            try self.validate(self.county, name: "county", parent: name, max: 255)
            try self.validate(self.county, name: "county", parent: name, min: 1)
            try self.postalCode?.forEach {}
            try self.validate(self.postalCode, name: "postalCode", parent: name, max: 255)
            try self.validate(self.postalCode, name: "postalCode", parent: name, min: 1)
            try self.province?.forEach {}
            try self.validate(self.province, name: "province", parent: name, max: 255)
            try self.validate(self.province, name: "province", parent: name, min: 1)
            try self.state?.forEach {}
            try self.validate(self.state, name: "state", parent: name, max: 255)
            try self.validate(self.state, name: "state", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case address1 = "Address1"
            case address2 = "Address2"
            case address3 = "Address3"
            case address4 = "Address4"
            case city = "City"
            case country = "Country"
            case county = "County"
            case postalCode = "PostalCode"
            case province = "Province"
            case state = "State"
        }
    }

    public struct ConnectorOperator: AWSEncodableShape {
        public let marketo: MarketoConnectorOperator?
        public let s3: S3ConnectorOperator?
        public let salesforce: SalesforceConnectorOperator?
        public let serviceNow: ServiceNowConnectorOperator?
        public let zendesk: ZendeskConnectorOperator?

        public init(marketo: MarketoConnectorOperator? = nil, s3: S3ConnectorOperator? = nil, salesforce: SalesforceConnectorOperator? = nil, serviceNow: ServiceNowConnectorOperator? = nil, zendesk: ZendeskConnectorOperator? = nil) {
            self.marketo = marketo
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.zendesk = zendesk
        }

        private enum CodingKeys: String, CodingKey {
            case marketo = "Marketo"
            case s3 = "S3"
            case salesforce = "Salesforce"
            case serviceNow = "ServiceNow"
            case zendesk = "Zendesk"
        }
    }

    public struct CreateDomainRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications. You must set up a policy on the DeadLetterQueue for the SendMessage operation to enable Amazon Connect Customer Profiles to send messages to the DeadLetterQueue.
        public let deadLetterQueueUrl: String?
        /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
        public let defaultEncryptionKey: String?
        /// The default number of days until the data within the domain expires.
        public let defaultExpirationDays: Int
        /// The unique name of the domain.
        public let domainName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(deadLetterQueueUrl: String? = nil, defaultEncryptionKey: String? = nil, defaultExpirationDays: Int, domainName: String, tags: [String: String]? = nil) {
            self.deadLetterQueueUrl = deadLetterQueueUrl
            self.defaultEncryptionKey = defaultEncryptionKey
            self.defaultExpirationDays = defaultExpirationDays
            self.domainName = domainName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.deadLetterQueueUrl?.forEach {}
            try self.validate(self.deadLetterQueueUrl, name: "deadLetterQueueUrl", parent: name, max: 255)
            try self.validate(self.deadLetterQueueUrl, name: "deadLetterQueueUrl", parent: name, min: 0)
            try self.defaultEncryptionKey?.forEach {}
            try self.validate(self.defaultEncryptionKey, name: "defaultEncryptionKey", parent: name, max: 255)
            try self.validate(self.defaultEncryptionKey, name: "defaultEncryptionKey", parent: name, min: 0)
            try self.defaultExpirationDays.forEach {}
            try self.validate(self.defaultExpirationDays, name: "defaultExpirationDays", parent: name, max: 1098)
            try self.validate(self.defaultExpirationDays, name: "defaultExpirationDays", parent: name, min: 1)
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case deadLetterQueueUrl = "DeadLetterQueueUrl"
            case defaultEncryptionKey = "DefaultEncryptionKey"
            case defaultExpirationDays = "DefaultExpirationDays"
            case tags = "Tags"
        }
    }

    public struct CreateDomainResponse: AWSDecodableShape {
        /// The timestamp of when the domain was created.
        public let createdAt: Date
        /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
        public let deadLetterQueueUrl: String?
        /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
        public let defaultEncryptionKey: String?
        /// The default number of days until the data within the domain expires.
        public let defaultExpirationDays: Int
        /// The unique name of the domain.
        public let domainName: String
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(createdAt: Date, deadLetterQueueUrl: String? = nil, defaultEncryptionKey: String? = nil, defaultExpirationDays: Int, domainName: String, lastUpdatedAt: Date, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.deadLetterQueueUrl = deadLetterQueueUrl
            self.defaultEncryptionKey = defaultEncryptionKey
            self.defaultExpirationDays = defaultExpirationDays
            self.domainName = domainName
            self.lastUpdatedAt = lastUpdatedAt
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case deadLetterQueueUrl = "DeadLetterQueueUrl"
            case defaultEncryptionKey = "DefaultEncryptionKey"
            case defaultExpirationDays = "DefaultExpirationDays"
            case domainName = "DomainName"
            case lastUpdatedAt = "LastUpdatedAt"
            case tags = "Tags"
        }
    }

    public struct CreateProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// A unique account number that you have given to the customer.
        public let accountNumber: String?
        /// Any additional information relevant to the customer's profile.
        public let additionalInformation: String?
        /// A generic address associated with the customer that is not mailing, shipping, or billing.
        public let address: Address?
        /// A key value pair of attributes of a customer profile.
        public let attributes: [String: String]?
        /// The customer’s billing address.
        public let billingAddress: Address?
        /// The customer’s birth date.
        public let birthDate: String?
        /// The customer’s business email address.
        public let businessEmailAddress: String?
        /// The name of the customer’s business.
        public let businessName: String?
        /// The customer’s business phone number.
        public let businessPhoneNumber: String?
        /// The unique name of the domain.
        public let domainName: String
        /// The customer's email address, which has not been specified as a personal or business address.
        public let emailAddress: String?
        /// The customer’s first name.
        public let firstName: String?
        /// The gender with which the customer identifies.
        public let gender: Gender?
        /// The customer’s home phone number.
        public let homePhoneNumber: String?
        /// The customer’s last name.
        public let lastName: String?
        /// The customer’s mailing address.
        public let mailingAddress: Address?
        /// The customer’s middle name.
        public let middleName: String?
        /// The customer’s mobile phone number.
        public let mobilePhoneNumber: String?
        /// The type of profile used to describe the customer.
        public let partyType: PartyType?
        /// The customer’s personal email address.
        public let personalEmailAddress: String?
        /// The customer's phone number, which has not been specified as a mobile, home, or business number.
        public let phoneNumber: String?
        /// The customer’s shipping address.
        public let shippingAddress: Address?

        public init(accountNumber: String? = nil, additionalInformation: String? = nil, address: Address? = nil, attributes: [String: String]? = nil, billingAddress: Address? = nil, birthDate: String? = nil, businessEmailAddress: String? = nil, businessName: String? = nil, businessPhoneNumber: String? = nil, domainName: String, emailAddress: String? = nil, firstName: String? = nil, gender: Gender? = nil, homePhoneNumber: String? = nil, lastName: String? = nil, mailingAddress: Address? = nil, middleName: String? = nil, mobilePhoneNumber: String? = nil, partyType: PartyType? = nil, personalEmailAddress: String? = nil, phoneNumber: String? = nil, shippingAddress: Address? = nil) {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address = address
            self.attributes = attributes
            self.billingAddress = billingAddress
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.domainName = domainName
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.gender = gender
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress = mailingAddress
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyType = partyType
            self.personalEmailAddress = personalEmailAddress
            self.phoneNumber = phoneNumber
            self.shippingAddress = shippingAddress
        }

        public func validate(name: String) throws {
            try self.accountNumber?.forEach {}
            try self.validate(self.accountNumber, name: "accountNumber", parent: name, max: 255)
            try self.validate(self.accountNumber, name: "accountNumber", parent: name, min: 1)
            try self.additionalInformation?.forEach {}
            try self.validate(self.additionalInformation, name: "additionalInformation", parent: name, max: 1000)
            try self.validate(self.additionalInformation, name: "additionalInformation", parent: name, min: 1)
            try self.address?.validate(name: "\(name).address")
            try self.address?.forEach {}
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 255)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 255)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, min: 1)
            }
            try self.billingAddress?.validate(name: "\(name).billingAddress")
            try self.billingAddress?.forEach {}
            try self.birthDate?.forEach {}
            try self.validate(self.birthDate, name: "birthDate", parent: name, max: 255)
            try self.validate(self.birthDate, name: "birthDate", parent: name, min: 1)
            try self.businessEmailAddress?.forEach {}
            try self.validate(self.businessEmailAddress, name: "businessEmailAddress", parent: name, max: 255)
            try self.validate(self.businessEmailAddress, name: "businessEmailAddress", parent: name, min: 1)
            try self.businessName?.forEach {}
            try self.validate(self.businessName, name: "businessName", parent: name, max: 255)
            try self.validate(self.businessName, name: "businessName", parent: name, min: 1)
            try self.businessPhoneNumber?.forEach {}
            try self.validate(self.businessPhoneNumber, name: "businessPhoneNumber", parent: name, max: 255)
            try self.validate(self.businessPhoneNumber, name: "businessPhoneNumber", parent: name, min: 1)
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.emailAddress?.forEach {}
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, max: 255)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, min: 1)
            try self.firstName?.forEach {}
            try self.validate(self.firstName, name: "firstName", parent: name, max: 255)
            try self.validate(self.firstName, name: "firstName", parent: name, min: 1)
            try self.homePhoneNumber?.forEach {}
            try self.validate(self.homePhoneNumber, name: "homePhoneNumber", parent: name, max: 255)
            try self.validate(self.homePhoneNumber, name: "homePhoneNumber", parent: name, min: 1)
            try self.lastName?.forEach {}
            try self.validate(self.lastName, name: "lastName", parent: name, max: 255)
            try self.validate(self.lastName, name: "lastName", parent: name, min: 1)
            try self.mailingAddress?.validate(name: "\(name).mailingAddress")
            try self.mailingAddress?.forEach {}
            try self.middleName?.forEach {}
            try self.validate(self.middleName, name: "middleName", parent: name, max: 255)
            try self.validate(self.middleName, name: "middleName", parent: name, min: 1)
            try self.mobilePhoneNumber?.forEach {}
            try self.validate(self.mobilePhoneNumber, name: "mobilePhoneNumber", parent: name, max: 255)
            try self.validate(self.mobilePhoneNumber, name: "mobilePhoneNumber", parent: name, min: 1)
            try self.personalEmailAddress?.forEach {}
            try self.validate(self.personalEmailAddress, name: "personalEmailAddress", parent: name, max: 255)
            try self.validate(self.personalEmailAddress, name: "personalEmailAddress", parent: name, min: 1)
            try self.phoneNumber?.forEach {}
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, max: 255)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, min: 1)
            try self.shippingAddress?.validate(name: "\(name).shippingAddress")
            try self.shippingAddress?.forEach {}
        }

        private enum CodingKeys: String, CodingKey {
            case accountNumber = "AccountNumber"
            case additionalInformation = "AdditionalInformation"
            case address = "Address"
            case attributes = "Attributes"
            case billingAddress = "BillingAddress"
            case birthDate = "BirthDate"
            case businessEmailAddress = "BusinessEmailAddress"
            case businessName = "BusinessName"
            case businessPhoneNumber = "BusinessPhoneNumber"
            case emailAddress = "EmailAddress"
            case firstName = "FirstName"
            case gender = "Gender"
            case homePhoneNumber = "HomePhoneNumber"
            case lastName = "LastName"
            case mailingAddress = "MailingAddress"
            case middleName = "MiddleName"
            case mobilePhoneNumber = "MobilePhoneNumber"
            case partyType = "PartyType"
            case personalEmailAddress = "PersonalEmailAddress"
            case phoneNumber = "PhoneNumber"
            case shippingAddress = "ShippingAddress"
        }
    }

    public struct CreateProfileResponse: AWSDecodableShape {
        /// The unique identifier of a customer profile.
        public let profileId: String

        public init(profileId: String) {
            self.profileId = profileId
        }

        private enum CodingKeys: String, CodingKey {
            case profileId = "ProfileId"
        }
    }

    public struct DeleteDomainRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// The unique name of the domain.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteDomainResponse: AWSDecodableShape {
        /// A message that indicates the delete request is done.
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct DeleteIntegrationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// The unique name of the domain.
        public let domainName: String
        /// The URI of the S3 bucket or any other type of data source.
        public let uri: String

        public init(domainName: String, uri: String) {
            self.domainName = domainName
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.uri.forEach {}
            try self.validate(self.uri, name: "uri", parent: name, max: 255)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "Uri"
        }
    }

    public struct DeleteIntegrationResponse: AWSDecodableShape {
        /// A message that indicates the delete request is done.
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct DeleteProfileKeyRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// The unique name of the domain.
        public let domainName: String
        /// A searchable identifier of a customer profile.
        public let keyName: String
        /// The unique identifier of a customer profile.
        public let profileId: String
        /// A list of key values.
        public let values: [String]

        public init(domainName: String, keyName: String, profileId: String, values: [String]) {
            self.domainName = domainName
            self.keyName = keyName
            self.profileId = profileId
            self.values = values
        }

        public func validate(name: String) throws {
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.keyName.forEach {}
            try self.validate(self.keyName, name: "keyName", parent: name, max: 64)
            try self.validate(self.keyName, name: "keyName", parent: name, min: 1)
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.profileId.forEach {}
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "[a-f0-9]{32}")
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.values.forEach {}
        }

        private enum CodingKeys: String, CodingKey {
            case keyName = "KeyName"
            case profileId = "ProfileId"
            case values = "Values"
        }
    }

    public struct DeleteProfileKeyResponse: AWSDecodableShape {
        /// A message that indicates the delete request is done.
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct DeleteProfileObjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// The unique name of the domain.
        public let domainName: String
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The unique identifier of a customer profile.
        public let profileId: String
        /// The unique identifier of the profile object generated by the service.
        public let profileObjectUniqueKey: String

        public init(domainName: String, objectTypeName: String, profileId: String, profileObjectUniqueKey: String) {
            self.domainName = domainName
            self.objectTypeName = objectTypeName
            self.profileId = profileId
            self.profileObjectUniqueKey = profileObjectUniqueKey
        }

        public func validate(name: String) throws {
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.objectTypeName.forEach {}
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.profileId.forEach {}
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "[a-f0-9]{32}")
            try self.profileObjectUniqueKey.forEach {}
            try self.validate(self.profileObjectUniqueKey, name: "profileObjectUniqueKey", parent: name, max: 255)
            try self.validate(self.profileObjectUniqueKey, name: "profileObjectUniqueKey", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case objectTypeName = "ObjectTypeName"
            case profileId = "ProfileId"
            case profileObjectUniqueKey = "ProfileObjectUniqueKey"
        }
    }

    public struct DeleteProfileObjectResponse: AWSDecodableShape {
        /// A message that indicates the delete request is done.
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct DeleteProfileObjectTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName")),
            AWSMemberEncoding(label: "objectTypeName", location: .uri(locationName: "ObjectTypeName"))
        ]

        /// The unique name of the domain.
        public let domainName: String
        /// The name of the profile object type.
        public let objectTypeName: String

        public init(domainName: String, objectTypeName: String) {
            self.domainName = domainName
            self.objectTypeName = objectTypeName
        }

        public func validate(name: String) throws {
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.objectTypeName.forEach {}
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct DeleteProfileObjectTypeResponse: AWSDecodableShape {
        /// A message that indicates the delete request is done.
        public let message: String

        public init(message: String) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct DeleteProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// The unique name of the domain.
        public let domainName: String
        /// The unique identifier of a customer profile.
        public let profileId: String

        public init(domainName: String, profileId: String) {
            self.domainName = domainName
            self.profileId = profileId
        }

        public func validate(name: String) throws {
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.profileId.forEach {}
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "[a-f0-9]{32}")
        }

        private enum CodingKeys: String, CodingKey {
            case profileId = "ProfileId"
        }
    }

    public struct DeleteProfileResponse: AWSDecodableShape {
        /// A message that indicates the delete request is done.
        public let message: String?

        public init(message: String? = nil) {
            self.message = message
        }

        private enum CodingKeys: String, CodingKey {
            case message = "Message"
        }
    }

    public struct DomainStats: AWSDecodableShape {
        /// The number of profiles that you are currently paying for in the domain. If you have more than 100 objects associated with a single profile, that profile counts as two profiles. If you have more than 200 objects, that profile counts as three, and so on.
        public let meteringProfileCount: Int64?
        /// The total number of objects in domain.
        public let objectCount: Int64?
        /// The total number of profiles currently in the domain.
        public let profileCount: Int64?
        /// The total size, in bytes, of all objects in the domain.
        public let totalSize: Int64?

        public init(meteringProfileCount: Int64? = nil, objectCount: Int64? = nil, profileCount: Int64? = nil, totalSize: Int64? = nil) {
            self.meteringProfileCount = meteringProfileCount
            self.objectCount = objectCount
            self.profileCount = profileCount
            self.totalSize = totalSize
        }

        private enum CodingKeys: String, CodingKey {
            case meteringProfileCount = "MeteringProfileCount"
            case objectCount = "ObjectCount"
            case profileCount = "ProfileCount"
            case totalSize = "TotalSize"
        }
    }

    public struct FlowDefinition: AWSEncodableShape {
        public let description: String?
        public let flowName: String
        public let kmsArn: String
        public let sourceFlowConfig: SourceFlowConfig
        public let tasks: [Task]
        public let triggerConfig: TriggerConfig

        public init(description: String? = nil, flowName: String, kmsArn: String, sourceFlowConfig: SourceFlowConfig, tasks: [Task], triggerConfig: TriggerConfig) {
            self.description = description
            self.flowName = flowName
            self.kmsArn = kmsArn
            self.sourceFlowConfig = sourceFlowConfig
            self.tasks = tasks
            self.triggerConfig = triggerConfig
        }

        public func validate(name: String) throws {
            try self.description?.forEach {}
            try self.validate(self.description, name: "description", parent: name, max: 2048)
            try self.validate(self.description, name: "description", parent: name, pattern: "[\\w!@#\\-.?,\\s]*")
            try self.flowName.forEach {}
            try self.validate(self.flowName, name: "flowName", parent: name, max: 256)
            try self.validate(self.flowName, name: "flowName", parent: name, pattern: "[a-zA-Z0-9][\\w!@#.-]+")
            try self.kmsArn.forEach {}
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, max: 2048)
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, min: 20)
            try self.validate(self.kmsArn, name: "kmsArn", parent: name, pattern: "arn:aws:kms:.*:[0-9]+:.*")
            try self.sourceFlowConfig.validate(name: "\(name).sourceFlowConfig")
            try self.sourceFlowConfig.forEach {}
            try self.tasks.forEach {
                try $0.validate(name: "\(name).tasks[]")
            }
            try self.tasks.forEach {}
            try self.triggerConfig.validate(name: "\(name).triggerConfig")
            try self.triggerConfig.forEach {}
        }

        private enum CodingKeys: String, CodingKey {
            case description = "Description"
            case flowName = "FlowName"
            case kmsArn = "KmsArn"
            case sourceFlowConfig = "SourceFlowConfig"
            case tasks = "Tasks"
            case triggerConfig = "TriggerConfig"
        }
    }

    public struct GetDomainRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// A unique name for the domain.
        public let domainName: String

        public init(domainName: String) {
            self.domainName = domainName
        }

        public func validate(name: String) throws {
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetDomainResponse: AWSDecodableShape {
        /// The timestamp of when the domain was created.
        public let createdAt: Date
        /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
        public let deadLetterQueueUrl: String?
        /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
        public let defaultEncryptionKey: String?
        /// The default number of days until the data within the domain expires.
        public let defaultExpirationDays: Int?
        /// The unique name of the domain.
        public let domainName: String
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date
        /// Usage-specific statistics about the domain.
        public let stats: DomainStats?
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(createdAt: Date, deadLetterQueueUrl: String? = nil, defaultEncryptionKey: String? = nil, defaultExpirationDays: Int? = nil, domainName: String, lastUpdatedAt: Date, stats: DomainStats? = nil, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.deadLetterQueueUrl = deadLetterQueueUrl
            self.defaultEncryptionKey = defaultEncryptionKey
            self.defaultExpirationDays = defaultExpirationDays
            self.domainName = domainName
            self.lastUpdatedAt = lastUpdatedAt
            self.stats = stats
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case deadLetterQueueUrl = "DeadLetterQueueUrl"
            case defaultEncryptionKey = "DefaultEncryptionKey"
            case defaultExpirationDays = "DefaultExpirationDays"
            case domainName = "DomainName"
            case lastUpdatedAt = "LastUpdatedAt"
            case stats = "Stats"
            case tags = "Tags"
        }
    }

    public struct GetIntegrationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// The unique name of the domain.
        public let domainName: String
        /// The URI of the S3 bucket or any other type of data source.
        public let uri: String

        public init(domainName: String, uri: String) {
            self.domainName = domainName
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.uri.forEach {}
            try self.validate(self.uri, name: "uri", parent: name, max: 255)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "Uri"
        }
    }

    public struct GetIntegrationResponse: AWSDecodableShape {
        /// The timestamp of when the domain was created.
        public let createdAt: Date
        /// The unique name of the domain.
        public let domainName: String
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The URI of the S3 bucket or any other type of data source.
        public let uri: String

        public init(createdAt: Date, domainName: String, lastUpdatedAt: Date, objectTypeName: String, tags: [String: String]? = nil, uri: String) {
            self.createdAt = createdAt
            self.domainName = domainName
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.tags = tags
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case domainName = "DomainName"
            case lastUpdatedAt = "LastUpdatedAt"
            case objectTypeName = "ObjectTypeName"
            case tags = "Tags"
            case uri = "Uri"
        }
    }

    public struct GetProfileObjectTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName")),
            AWSMemberEncoding(label: "objectTypeName", location: .uri(locationName: "ObjectTypeName"))
        ]

        /// The unique name of the domain.
        public let domainName: String
        /// The name of the profile object type.
        public let objectTypeName: String

        public init(domainName: String, objectTypeName: String) {
            self.domainName = domainName
            self.objectTypeName = objectTypeName
        }

        public func validate(name: String) throws {
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.objectTypeName.forEach {}
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProfileObjectTypeResponse: AWSDecodableShape {
        /// Indicates whether a profile should be created when data is received if one doesn’t exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
        public let allowProfileCreation: Bool?
        /// The timestamp of when the domain was created.
        public let createdAt: Date?
        /// The description of the profile object type.
        public let description: String
        /// The customer-provided key to encrypt the profile object that will be created in this profile object type.
        public let encryptionKey: String?
        /// The number of days until the data in the object expires.
        public let expirationDays: Int?
        /// A map of the name and ObjectType field.
        public let fields: [String: ObjectTypeField]?
        /// A list of unique keys that can be used to map data to the profile.
        public let keys: [String: [ObjectTypeKey]]?
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date?
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// A unique identifier for the object template.
        public let templateId: String?

        public init(allowProfileCreation: Bool? = nil, createdAt: Date? = nil, description: String, encryptionKey: String? = nil, expirationDays: Int? = nil, fields: [String: ObjectTypeField]? = nil, keys: [String: [ObjectTypeKey]]? = nil, lastUpdatedAt: Date? = nil, objectTypeName: String, tags: [String: String]? = nil, templateId: String? = nil) {
            self.allowProfileCreation = allowProfileCreation
            self.createdAt = createdAt
            self.description = description
            self.encryptionKey = encryptionKey
            self.expirationDays = expirationDays
            self.fields = fields
            self.keys = keys
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.tags = tags
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case allowProfileCreation = "AllowProfileCreation"
            case createdAt = "CreatedAt"
            case description = "Description"
            case encryptionKey = "EncryptionKey"
            case expirationDays = "ExpirationDays"
            case fields = "Fields"
            case keys = "Keys"
            case lastUpdatedAt = "LastUpdatedAt"
            case objectTypeName = "ObjectTypeName"
            case tags = "Tags"
            case templateId = "TemplateId"
        }
    }

    public struct GetProfileObjectTypeTemplateRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "templateId", location: .uri(locationName: "TemplateId"))
        ]

        /// A unique identifier for the object template.
        public let templateId: String

        public init(templateId: String) {
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.templateId.forEach {}
            try self.validate(self.templateId, name: "templateId", parent: name, max: 64)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct GetProfileObjectTypeTemplateResponse: AWSDecodableShape {
        /// Indicates whether a profile should be created when data is received if one doesn’t exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
        public let allowProfileCreation: Bool?
        /// A map of the name and ObjectType field.
        public let fields: [String: ObjectTypeField]?
        /// A list of unique keys that can be used to map data to the profile.
        public let keys: [String: [ObjectTypeKey]]?
        /// The name of the source of the object template.
        public let sourceName: String?
        /// The source of the object template.
        public let sourceObject: String?
        /// A unique identifier for the object template.
        public let templateId: String?

        public init(allowProfileCreation: Bool? = nil, fields: [String: ObjectTypeField]? = nil, keys: [String: [ObjectTypeKey]]? = nil, sourceName: String? = nil, sourceObject: String? = nil, templateId: String? = nil) {
            self.allowProfileCreation = allowProfileCreation
            self.fields = fields
            self.keys = keys
            self.sourceName = sourceName
            self.sourceObject = sourceObject
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case allowProfileCreation = "AllowProfileCreation"
            case fields = "Fields"
            case keys = "Keys"
            case sourceName = "SourceName"
            case sourceObject = "SourceObject"
            case templateId = "TemplateId"
        }
    }

    public struct IncrementalPullConfig: AWSEncodableShape {
        public let datetimeTypeFieldName: String?

        public init(datetimeTypeFieldName: String? = nil) {
            self.datetimeTypeFieldName = datetimeTypeFieldName
        }

        public func validate(name: String) throws {
            try self.datetimeTypeFieldName?.forEach {}
            try self.validate(self.datetimeTypeFieldName, name: "datetimeTypeFieldName", parent: name, max: 256)
            try self.validate(self.datetimeTypeFieldName, name: "datetimeTypeFieldName", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case datetimeTypeFieldName = "DatetimeTypeFieldName"
        }
    }

    public struct ListAccountIntegrationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous ListAccountIntegrations API call.
        public let nextToken: String?
        /// The URI of the S3 bucket or any other type of data source.
        public let uri: String

        public init(maxResults: Int? = nil, nextToken: String? = nil, uri: String) {
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.maxResults?.forEach {}
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.nextToken?.forEach {}
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.uri.forEach {}
            try self.validate(self.uri, name: "uri", parent: name, max: 255)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case uri = "Uri"
        }
    }

    public struct ListAccountIntegrationsResponse: AWSDecodableShape {
        /// The list of ListAccountIntegration instances.
        public let items: [ListIntegrationItem]?
        /// The pagination token from the previous ListAccountIntegrations API call.
        public let nextToken: String?

        public init(items: [ListIntegrationItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListDomainItem: AWSDecodableShape {
        /// The timestamp of when the domain was created.
        public let createdAt: Date
        /// The unique name of the domain.
        public let domainName: String
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(createdAt: Date, domainName: String, lastUpdatedAt: Date, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.domainName = domainName
            self.lastUpdatedAt = lastUpdatedAt
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case domainName = "DomainName"
            case lastUpdatedAt = "LastUpdatedAt"
            case tags = "Tags"
        }
    }

    public struct ListDomainsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous ListDomain API call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.maxResults?.forEach {}
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.nextToken?.forEach {}
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListDomainsResponse: AWSDecodableShape {
        /// The list of ListDomains instances.
        public let items: [ListDomainItem]?
        /// The pagination token from the previous ListDomains API call.
        public let nextToken: String?

        public init(items: [ListDomainItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListIntegrationItem: AWSDecodableShape {
        /// The timestamp of when the domain was created.
        public let createdAt: Date
        /// The unique name of the domain.
        public let domainName: String
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The URI of the S3 bucket or any other type of data source.
        public let uri: String

        public init(createdAt: Date, domainName: String, lastUpdatedAt: Date, objectTypeName: String, tags: [String: String]? = nil, uri: String) {
            self.createdAt = createdAt
            self.domainName = domainName
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.tags = tags
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case domainName = "DomainName"
            case lastUpdatedAt = "LastUpdatedAt"
            case objectTypeName = "ObjectTypeName"
            case tags = "Tags"
            case uri = "Uri"
        }
    }

    public struct ListIntegrationsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The unique name of the domain.
        public let domainName: String
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous ListIntegrations API call.
        public let nextToken: String?

        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.maxResults?.forEach {}
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.nextToken?.forEach {}
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListIntegrationsResponse: AWSDecodableShape {
        /// The list of ListIntegrations instances.
        public let items: [ListIntegrationItem]?
        /// The pagination token from the previous ListIntegrations API call.
        public let nextToken: String?

        public init(items: [ListIntegrationItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListProfileObjectTypeItem: AWSDecodableShape {
        /// The timestamp of when the domain was created.
        public let createdAt: Date?
        /// Description of the profile object type.
        public let description: String
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date?
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(createdAt: Date? = nil, description: String, lastUpdatedAt: Date? = nil, objectTypeName: String, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.description = description
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case description = "Description"
            case lastUpdatedAt = "LastUpdatedAt"
            case objectTypeName = "ObjectTypeName"
            case tags = "Tags"
        }
    }

    public struct ListProfileObjectTypeTemplateItem: AWSDecodableShape {
        /// The name of the source of the object template.
        public let sourceName: String?
        /// The source of the object template.
        public let sourceObject: String?
        /// A unique identifier for the object template.
        public let templateId: String?

        public init(sourceName: String? = nil, sourceObject: String? = nil, templateId: String? = nil) {
            self.sourceName = sourceName
            self.sourceObject = sourceObject
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case sourceName = "SourceName"
            case sourceObject = "SourceObject"
            case templateId = "TemplateId"
        }
    }

    public struct ListProfileObjectTypeTemplatesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous ListObjectTypeTemplates API call.
        public let nextToken: String?

        public init(maxResults: Int? = nil, nextToken: String? = nil) {
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.maxResults?.forEach {}
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.nextToken?.forEach {}
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProfileObjectTypeTemplatesResponse: AWSDecodableShape {
        /// The list of ListProfileObjectType template instances.
        public let items: [ListProfileObjectTypeTemplateItem]?
        /// The pagination token from the previous ListObjectTypeTemplates API call.
        public let nextToken: String?

        public init(items: [ListProfileObjectTypeTemplateItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListProfileObjectTypesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The unique name of the domain.
        public let domainName: String
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
        }

        public func validate(name: String) throws {
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.maxResults?.forEach {}
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.nextToken?.forEach {}
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListProfileObjectTypesResponse: AWSDecodableShape {
        /// The list of ListProfileObjectTypes instances.
        public let items: [ListProfileObjectTypeItem]?
        /// Identifies the next page of results to return.
        public let nextToken: String?

        public init(items: [ListProfileObjectTypeItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListProfileObjectsItem: AWSDecodableShape {
        /// A JSON representation of a ProfileObject that belongs to a profile.
        public let object: String?
        /// Specifies the kind of object being added to a profile, such as "Salesforce-Account."
        public let objectTypeName: String?
        /// The unique identifier of the ProfileObject generated by the service.
        public let profileObjectUniqueKey: String?

        public init(object: String? = nil, objectTypeName: String? = nil, profileObjectUniqueKey: String? = nil) {
            self.object = object
            self.objectTypeName = objectTypeName
            self.profileObjectUniqueKey = profileObjectUniqueKey
        }

        private enum CodingKeys: String, CodingKey {
            case object = "Object"
            case objectTypeName = "ObjectTypeName"
            case profileObjectUniqueKey = "ProfileObjectUniqueKey"
        }
    }

    public struct ListProfileObjectsRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The unique name of the domain.
        public let domainName: String
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous call to ListProfileObjects.
        public let nextToken: String?
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The unique identifier of a customer profile.
        public let profileId: String

        public init(domainName: String, maxResults: Int? = nil, nextToken: String? = nil, objectTypeName: String, profileId: String) {
            self.domainName = domainName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.objectTypeName = objectTypeName
            self.profileId = profileId
        }

        public func validate(name: String) throws {
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.maxResults?.forEach {}
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.nextToken?.forEach {}
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.objectTypeName.forEach {}
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.profileId.forEach {}
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "[a-f0-9]{32}")
        }

        private enum CodingKeys: String, CodingKey {
            case objectTypeName = "ObjectTypeName"
            case profileId = "ProfileId"
        }
    }

    public struct ListProfileObjectsResponse: AWSDecodableShape {
        /// The list of ListProfileObject instances.
        public let items: [ListProfileObjectsItem]?
        /// The pagination token from the previous call to ListProfileObjects.
        public let nextToken: String?

        public init(items: [ListProfileObjectsItem]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ListTagsForResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The ARN of the resource for which you want to view tags.
        public let resourceArn: String

        public init(resourceArn: String) {
            self.resourceArn = resourceArn
        }

        public func validate(name: String) throws {
            try self.resourceArn.forEach {}
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z0-9]{1,10}:profile")
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct ListTagsForResourceResponse: AWSDecodableShape {
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(tags: [String: String]? = nil) {
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct MarketoSourceProperties: AWSEncodableShape {
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.object.forEach {}
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "Object"
        }
    }

    public struct ObjectTypeField: AWSEncodableShape & AWSDecodableShape {
        /// The content type of the field. Used for determining equality when searching.
        public let contentType: FieldContentType?
        /// A field of a ProfileObject. For example: _source.FirstName, where “_source” is a ProfileObjectType of a Zendesk user and “FirstName” is a field in that ObjectType.
        public let source: String?
        /// The location of the data in the standard ProfileObject model. For example: _profile.Address.PostalCode.
        public let target: String?

        public init(contentType: FieldContentType? = nil, source: String? = nil, target: String? = nil) {
            self.contentType = contentType
            self.source = source
            self.target = target
        }

        public func validate(name: String) throws {
            try self.source?.forEach {}
            try self.validate(self.source, name: "source", parent: name, max: 1000)
            try self.validate(self.source, name: "source", parent: name, min: 1)
            try self.target?.forEach {}
            try self.validate(self.target, name: "target", parent: name, max: 1000)
            try self.validate(self.target, name: "target", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case contentType = "ContentType"
            case source = "Source"
            case target = "Target"
        }
    }

    public struct ObjectTypeKey: AWSEncodableShape & AWSDecodableShape {
        /// The reference for the key name of the fields map.
        public let fieldNames: [String]?
        /// The types of keys that a ProfileObject can have. Each ProfileObject can have only 1 UNIQUE key but multiple PROFILE keys. PROFILE means that this key can be used to tie an object to a PROFILE. UNIQUE means that it can be used to uniquely identify an object. If a key a is marked as SECONDARY, it will be used to search for profiles after all other PROFILE keys have been searched. A LOOKUP_ONLY key is only used to match a profile but is not persisted to be used for searching of the profile. A NEW_ONLY key is only used if the profile does not already exist before the object is ingested, otherwise it is only used for matching objects to profiles.
        public let standardIdentifiers: [StandardIdentifier]?

        public init(fieldNames: [String]? = nil, standardIdentifiers: [StandardIdentifier]? = nil) {
            self.fieldNames = fieldNames
            self.standardIdentifiers = standardIdentifiers
        }

        public func validate(name: String) throws {
            try self.fieldNames?.forEach {
                try validate($0, name: "fieldNames[]", parent: name, max: 64)
                try validate($0, name: "fieldNames[]", parent: name, min: 1)
                try validate($0, name: "fieldNames[]", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            }
            try self.fieldNames?.forEach {}
        }

        private enum CodingKeys: String, CodingKey {
            case fieldNames = "FieldNames"
            case standardIdentifiers = "StandardIdentifiers"
        }
    }

    public struct Profile: AWSDecodableShape {
        /// A unique account number that you have given to the customer.
        public let accountNumber: String?
        /// Any additional information relevant to the customer's profile.
        public let additionalInformation: String?
        /// A generic address associated with the customer that is not mailing, shipping, or billing.
        public let address: Address?
        /// A key value pair of attributes of a customer profile.
        public let attributes: [String: String]?
        /// The customer’s billing address.
        public let billingAddress: Address?
        /// The customer’s birth date.
        public let birthDate: String?
        /// The customer’s business email address.
        public let businessEmailAddress: String?
        /// The name of the customer’s business.
        public let businessName: String?
        /// The customer’s home phone number.
        public let businessPhoneNumber: String?
        /// The customer's email address, which has not been specified as a personal or business address.
        public let emailAddress: String?
        /// The customer’s first name.
        public let firstName: String?
        /// The gender with which the customer identifies.
        public let gender: Gender?
        /// The customer’s home phone number.
        public let homePhoneNumber: String?
        /// The customer’s last name.
        public let lastName: String?
        /// The customer’s mailing address.
        public let mailingAddress: Address?
        /// The customer’s middle name.
        public let middleName: String?
        /// The customer’s mobile phone number.
        public let mobilePhoneNumber: String?
        /// The type of profile used to describe the customer.
        public let partyType: PartyType?
        /// The customer’s personal email address.
        public let personalEmailAddress: String?
        /// The customer's phone number, which has not been specified as a mobile, home, or business number.
        public let phoneNumber: String?
        /// The unique identifier of a customer profile.
        public let profileId: String?
        /// The customer’s shipping address.
        public let shippingAddress: Address?

        public init(accountNumber: String? = nil, additionalInformation: String? = nil, address: Address? = nil, attributes: [String: String]? = nil, billingAddress: Address? = nil, birthDate: String? = nil, businessEmailAddress: String? = nil, businessName: String? = nil, businessPhoneNumber: String? = nil, emailAddress: String? = nil, firstName: String? = nil, gender: Gender? = nil, homePhoneNumber: String? = nil, lastName: String? = nil, mailingAddress: Address? = nil, middleName: String? = nil, mobilePhoneNumber: String? = nil, partyType: PartyType? = nil, personalEmailAddress: String? = nil, phoneNumber: String? = nil, profileId: String? = nil, shippingAddress: Address? = nil) {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address = address
            self.attributes = attributes
            self.billingAddress = billingAddress
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.gender = gender
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress = mailingAddress
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyType = partyType
            self.personalEmailAddress = personalEmailAddress
            self.phoneNumber = phoneNumber
            self.profileId = profileId
            self.shippingAddress = shippingAddress
        }

        private enum CodingKeys: String, CodingKey {
            case accountNumber = "AccountNumber"
            case additionalInformation = "AdditionalInformation"
            case address = "Address"
            case attributes = "Attributes"
            case billingAddress = "BillingAddress"
            case birthDate = "BirthDate"
            case businessEmailAddress = "BusinessEmailAddress"
            case businessName = "BusinessName"
            case businessPhoneNumber = "BusinessPhoneNumber"
            case emailAddress = "EmailAddress"
            case firstName = "FirstName"
            case gender = "Gender"
            case homePhoneNumber = "HomePhoneNumber"
            case lastName = "LastName"
            case mailingAddress = "MailingAddress"
            case middleName = "MiddleName"
            case mobilePhoneNumber = "MobilePhoneNumber"
            case partyType = "PartyType"
            case personalEmailAddress = "PersonalEmailAddress"
            case phoneNumber = "PhoneNumber"
            case profileId = "ProfileId"
            case shippingAddress = "ShippingAddress"
        }
    }

    public struct PutIntegrationRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// The unique name of the domain.
        public let domainName: String
        public let flowDefinition: FlowDefinition?
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The URI of the S3 bucket or any other type of data source.
        public let uri: String?

        public init(domainName: String, flowDefinition: FlowDefinition? = nil, objectTypeName: String, tags: [String: String]? = nil, uri: String? = nil) {
            self.domainName = domainName
            self.flowDefinition = flowDefinition
            self.objectTypeName = objectTypeName
            self.tags = tags
            self.uri = uri
        }

        public func validate(name: String) throws {
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.flowDefinition?.validate(name: "\(name).flowDefinition")
            try self.flowDefinition?.forEach {}
            try self.objectTypeName.forEach {}
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.uri?.forEach {}
            try self.validate(self.uri, name: "uri", parent: name, max: 255)
            try self.validate(self.uri, name: "uri", parent: name, min: 1)
        }

        private enum CodingKeys: String, CodingKey {
            case flowDefinition = "FlowDefinition"
            case objectTypeName = "ObjectTypeName"
            case tags = "Tags"
            case uri = "Uri"
        }
    }

    public struct PutIntegrationResponse: AWSDecodableShape {
        /// The timestamp of when the domain was created.
        public let createdAt: Date
        /// The unique name of the domain.
        public let domainName: String
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// The URI of the S3 bucket or any other type of data source.
        public let uri: String

        public init(createdAt: Date, domainName: String, lastUpdatedAt: Date, objectTypeName: String, tags: [String: String]? = nil, uri: String) {
            self.createdAt = createdAt
            self.domainName = domainName
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.tags = tags
            self.uri = uri
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case domainName = "DomainName"
            case lastUpdatedAt = "LastUpdatedAt"
            case objectTypeName = "ObjectTypeName"
            case tags = "Tags"
            case uri = "Uri"
        }
    }

    public struct PutProfileObjectRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// The unique name of the domain.
        public let domainName: String
        /// A string that is serialized from a JSON object.
        public let object: String
        /// The name of the profile object type.
        public let objectTypeName: String

        public init(domainName: String, object: String, objectTypeName: String) {
            self.domainName = domainName
            self.object = object
            self.objectTypeName = objectTypeName
        }

        public func validate(name: String) throws {
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.object.forEach {}
            try self.validate(self.object, name: "object", parent: name, max: 256_000)
            try self.validate(self.object, name: "object", parent: name, min: 1)
            try self.objectTypeName.forEach {}
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "Object"
            case objectTypeName = "ObjectTypeName"
        }
    }

    public struct PutProfileObjectResponse: AWSDecodableShape {
        /// The unique identifier of the profile object generated by the service.
        public let profileObjectUniqueKey: String?

        public init(profileObjectUniqueKey: String? = nil) {
            self.profileObjectUniqueKey = profileObjectUniqueKey
        }

        private enum CodingKeys: String, CodingKey {
            case profileObjectUniqueKey = "ProfileObjectUniqueKey"
        }
    }

    public struct PutProfileObjectTypeRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName")),
            AWSMemberEncoding(label: "objectTypeName", location: .uri(locationName: "ObjectTypeName"))
        ]

        /// Indicates whether a profile should be created when data is received if one doesn’t exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
        public let allowProfileCreation: Bool?
        /// Description of the profile object type.
        public let description: String
        /// The unique name of the domain.
        public let domainName: String
        /// The customer-provided key to encrypt the profile object that will be created in this profile object type.
        public let encryptionKey: String?
        /// The number of days until the data in the object expires.
        public let expirationDays: Int?
        /// A map of the name and ObjectType field.
        public let fields: [String: ObjectTypeField]?
        /// A list of unique keys that can be used to map data to the profile.
        public let keys: [String: [ObjectTypeKey]]?
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// A unique identifier for the object template.
        public let templateId: String?

        public init(allowProfileCreation: Bool? = nil, description: String, domainName: String, encryptionKey: String? = nil, expirationDays: Int? = nil, fields: [String: ObjectTypeField]? = nil, keys: [String: [ObjectTypeKey]]? = nil, objectTypeName: String, tags: [String: String]? = nil, templateId: String? = nil) {
            self.allowProfileCreation = allowProfileCreation
            self.description = description
            self.domainName = domainName
            self.encryptionKey = encryptionKey
            self.expirationDays = expirationDays
            self.fields = fields
            self.keys = keys
            self.objectTypeName = objectTypeName
            self.tags = tags
            self.templateId = templateId
        }

        public func validate(name: String) throws {
            try self.description.forEach {}
            try self.validate(self.description, name: "description", parent: name, max: 1000)
            try self.validate(self.description, name: "description", parent: name, min: 1)
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.encryptionKey?.forEach {}
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, max: 255)
            try self.validate(self.encryptionKey, name: "encryptionKey", parent: name, min: 0)
            try self.expirationDays?.forEach {}
            try self.validate(self.expirationDays, name: "expirationDays", parent: name, max: 1098)
            try self.validate(self.expirationDays, name: "expirationDays", parent: name, min: 1)
            try self.fields?.forEach {
                try validate($0.key, name: "fields.key", parent: name, max: 64)
                try validate($0.key, name: "fields.key", parent: name, min: 1)
                try validate($0.key, name: "fields.key", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
                try $0.value.validate(name: "\(name).fields[\"\($0.key)\"]")
            }
            try self.keys?.forEach {
                try validate($0.key, name: "keys.key", parent: name, max: 64)
                try validate($0.key, name: "keys.key", parent: name, min: 1)
                try validate($0.key, name: "keys.key", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            }
            try self.objectTypeName.forEach {}
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, max: 255)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, min: 1)
            try self.validate(self.objectTypeName, name: "objectTypeName", parent: name, pattern: "^[a-zA-Z_][a-zA-Z_0-9-]*$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
            try self.templateId?.forEach {}
            try self.validate(self.templateId, name: "templateId", parent: name, max: 64)
            try self.validate(self.templateId, name: "templateId", parent: name, min: 1)
            try self.validate(self.templateId, name: "templateId", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
        }

        private enum CodingKeys: String, CodingKey {
            case allowProfileCreation = "AllowProfileCreation"
            case description = "Description"
            case encryptionKey = "EncryptionKey"
            case expirationDays = "ExpirationDays"
            case fields = "Fields"
            case keys = "Keys"
            case tags = "Tags"
            case templateId = "TemplateId"
        }
    }

    public struct PutProfileObjectTypeResponse: AWSDecodableShape {
        /// Indicates whether a profile should be created when data is received if one doesn’t exist for an object of this type. The default is FALSE. If the AllowProfileCreation flag is set to FALSE, then the service tries to fetch a standard profile and associate this object with the profile. If it is set to TRUE, and if no match is found, then the service creates a new standard profile.
        public let allowProfileCreation: Bool?
        /// The timestamp of when the domain was created.
        public let createdAt: Date?
        /// Description of the profile object type.
        public let description: String
        /// The customer-provided key to encrypt the profile object that will be created in this profile object type.
        public let encryptionKey: String?
        /// The number of days until the data in the object expires.
        public let expirationDays: Int?
        /// A map of the name and ObjectType field.
        public let fields: [String: ObjectTypeField]?
        /// A list of unique keys that can be used to map data to the profile.
        public let keys: [String: [ObjectTypeKey]]?
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date?
        /// The name of the profile object type.
        public let objectTypeName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?
        /// A unique identifier for the object template.
        public let templateId: String?

        public init(allowProfileCreation: Bool? = nil, createdAt: Date? = nil, description: String, encryptionKey: String? = nil, expirationDays: Int? = nil, fields: [String: ObjectTypeField]? = nil, keys: [String: [ObjectTypeKey]]? = nil, lastUpdatedAt: Date? = nil, objectTypeName: String, tags: [String: String]? = nil, templateId: String? = nil) {
            self.allowProfileCreation = allowProfileCreation
            self.createdAt = createdAt
            self.description = description
            self.encryptionKey = encryptionKey
            self.expirationDays = expirationDays
            self.fields = fields
            self.keys = keys
            self.lastUpdatedAt = lastUpdatedAt
            self.objectTypeName = objectTypeName
            self.tags = tags
            self.templateId = templateId
        }

        private enum CodingKeys: String, CodingKey {
            case allowProfileCreation = "AllowProfileCreation"
            case createdAt = "CreatedAt"
            case description = "Description"
            case encryptionKey = "EncryptionKey"
            case expirationDays = "ExpirationDays"
            case fields = "Fields"
            case keys = "Keys"
            case lastUpdatedAt = "LastUpdatedAt"
            case objectTypeName = "ObjectTypeName"
            case tags = "Tags"
            case templateId = "TemplateId"
        }
    }

    public struct S3SourceProperties: AWSEncodableShape {
        public let bucketName: String
        public let bucketPrefix: String?

        public init(bucketName: String, bucketPrefix: String? = nil) {
            self.bucketName = bucketName
            self.bucketPrefix = bucketPrefix
        }

        public func validate(name: String) throws {
            try self.bucketName.forEach {}
            try self.validate(self.bucketName, name: "bucketName", parent: name, max: 63)
            try self.validate(self.bucketName, name: "bucketName", parent: name, min: 3)
            try self.validate(self.bucketName, name: "bucketName", parent: name, pattern: "\\S+")
            try self.bucketPrefix?.forEach {}
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, max: 512)
            try self.validate(self.bucketPrefix, name: "bucketPrefix", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case bucketName = "BucketName"
            case bucketPrefix = "BucketPrefix"
        }
    }

    public struct SalesforceSourceProperties: AWSEncodableShape {
        public let enableDynamicFieldUpdate: Bool?
        public let includeDeletedRecords: Bool?
        public let object: String

        public init(enableDynamicFieldUpdate: Bool? = nil, includeDeletedRecords: Bool? = nil, object: String) {
            self.enableDynamicFieldUpdate = enableDynamicFieldUpdate
            self.includeDeletedRecords = includeDeletedRecords
            self.object = object
        }

        public func validate(name: String) throws {
            try self.object.forEach {}
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case enableDynamicFieldUpdate = "EnableDynamicFieldUpdate"
            case includeDeletedRecords = "IncludeDeletedRecords"
            case object = "Object"
        }
    }

    public struct ScheduledTriggerProperties: AWSEncodableShape {
        public let dataPullMode: DataPullMode?
        public let firstExecutionFrom: Date?
        public let scheduleEndTime: Date?
        public let scheduleExpression: String
        public let scheduleOffset: Int64?
        public let scheduleStartTime: Date?
        public let timezone: String?

        public init(dataPullMode: DataPullMode? = nil, firstExecutionFrom: Date? = nil, scheduleEndTime: Date? = nil, scheduleExpression: String, scheduleOffset: Int64? = nil, scheduleStartTime: Date? = nil, timezone: String? = nil) {
            self.dataPullMode = dataPullMode
            self.firstExecutionFrom = firstExecutionFrom
            self.scheduleEndTime = scheduleEndTime
            self.scheduleExpression = scheduleExpression
            self.scheduleOffset = scheduleOffset
            self.scheduleStartTime = scheduleStartTime
            self.timezone = timezone
        }

        public func validate(name: String) throws {
            try self.scheduleExpression.forEach {}
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, max: 256)
            try self.validate(self.scheduleExpression, name: "scheduleExpression", parent: name, pattern: ".*")
            try self.scheduleOffset?.forEach {}
            try self.validate(self.scheduleOffset, name: "scheduleOffset", parent: name, max: 36000)
            try self.validate(self.scheduleOffset, name: "scheduleOffset", parent: name, min: 0)
            try self.timezone?.forEach {}
            try self.validate(self.timezone, name: "timezone", parent: name, max: 256)
            try self.validate(self.timezone, name: "timezone", parent: name, pattern: ".*")
        }

        private enum CodingKeys: String, CodingKey {
            case dataPullMode = "DataPullMode"
            case firstExecutionFrom = "FirstExecutionFrom"
            case scheduleEndTime = "ScheduleEndTime"
            case scheduleExpression = "ScheduleExpression"
            case scheduleOffset = "ScheduleOffset"
            case scheduleStartTime = "ScheduleStartTime"
            case timezone = "Timezone"
        }
    }

    public struct SearchProfilesRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName")),
            AWSMemberEncoding(label: "maxResults", location: .querystring(locationName: "max-results")),
            AWSMemberEncoding(label: "nextToken", location: .querystring(locationName: "next-token"))
        ]

        /// The unique name of the domain.
        public let domainName: String
        /// A searchable identifier of a customer profile. The predefined keys you can use to search include: _account, _profileId, _fullName, _phone, _email, _ctrContactId, _marketoLeadId, _salesforceAccountId, _salesforceContactId, _zendeskUserId, _zendeskExternalId, _serviceNowSystemId.
        public let keyName: String
        /// The maximum number of objects returned per page.
        public let maxResults: Int?
        /// The pagination token from the previous SearchProfiles API call.
        public let nextToken: String?
        /// A list of key values.
        public let values: [String]

        public init(domainName: String, keyName: String, maxResults: Int? = nil, nextToken: String? = nil, values: [String]) {
            self.domainName = domainName
            self.keyName = keyName
            self.maxResults = maxResults
            self.nextToken = nextToken
            self.values = values
        }

        public func validate(name: String) throws {
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.keyName.forEach {}
            try self.validate(self.keyName, name: "keyName", parent: name, max: 64)
            try self.validate(self.keyName, name: "keyName", parent: name, min: 1)
            try self.validate(self.keyName, name: "keyName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.maxResults?.forEach {}
            try self.validate(self.maxResults, name: "maxResults", parent: name, max: 100)
            try self.validate(self.maxResults, name: "maxResults", parent: name, min: 1)
            try self.nextToken?.forEach {}
            try self.validate(self.nextToken, name: "nextToken", parent: name, max: 1024)
            try self.validate(self.nextToken, name: "nextToken", parent: name, min: 1)
            try self.values.forEach {
                try validate($0, name: "values[]", parent: name, max: 255)
                try validate($0, name: "values[]", parent: name, min: 1)
            }
            try self.values.forEach {}
        }

        private enum CodingKeys: String, CodingKey {
            case keyName = "KeyName"
            case values = "Values"
        }
    }

    public struct SearchProfilesResponse: AWSDecodableShape {
        /// The list of SearchProfiles instances.
        public let items: [Profile]?
        /// The pagination token from the previous SearchProfiles API call.
        public let nextToken: String?

        public init(items: [Profile]? = nil, nextToken: String? = nil) {
            self.items = items
            self.nextToken = nextToken
        }

        private enum CodingKeys: String, CodingKey {
            case items = "Items"
            case nextToken = "NextToken"
        }
    }

    public struct ServiceNowSourceProperties: AWSEncodableShape {
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.object.forEach {}
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "Object"
        }
    }

    public struct SourceConnectorProperties: AWSEncodableShape {
        public let marketo: MarketoSourceProperties?
        public let s3: S3SourceProperties?
        public let salesforce: SalesforceSourceProperties?
        public let serviceNow: ServiceNowSourceProperties?
        public let zendesk: ZendeskSourceProperties?

        public init(marketo: MarketoSourceProperties? = nil, s3: S3SourceProperties? = nil, salesforce: SalesforceSourceProperties? = nil, serviceNow: ServiceNowSourceProperties? = nil, zendesk: ZendeskSourceProperties? = nil) {
            self.marketo = marketo
            self.s3 = s3
            self.salesforce = salesforce
            self.serviceNow = serviceNow
            self.zendesk = zendesk
        }

        public func validate(name: String) throws {
            try self.marketo?.validate(name: "\(name).marketo")
            try self.marketo?.forEach {}
            try self.s3?.validate(name: "\(name).s3")
            try self.s3?.forEach {}
            try self.salesforce?.validate(name: "\(name).salesforce")
            try self.salesforce?.forEach {}
            try self.serviceNow?.validate(name: "\(name).serviceNow")
            try self.serviceNow?.forEach {}
            try self.zendesk?.validate(name: "\(name).zendesk")
            try self.zendesk?.forEach {}
        }

        private enum CodingKeys: String, CodingKey {
            case marketo = "Marketo"
            case s3 = "S3"
            case salesforce = "Salesforce"
            case serviceNow = "ServiceNow"
            case zendesk = "Zendesk"
        }
    }

    public struct SourceFlowConfig: AWSEncodableShape {
        public let connectorProfileName: String?
        public let connectorType: SourceConnectorType
        public let incrementalPullConfig: IncrementalPullConfig?
        public let sourceConnectorProperties: SourceConnectorProperties

        public init(connectorProfileName: String? = nil, connectorType: SourceConnectorType, incrementalPullConfig: IncrementalPullConfig? = nil, sourceConnectorProperties: SourceConnectorProperties) {
            self.connectorProfileName = connectorProfileName
            self.connectorType = connectorType
            self.incrementalPullConfig = incrementalPullConfig
            self.sourceConnectorProperties = sourceConnectorProperties
        }

        public func validate(name: String) throws {
            try self.connectorProfileName?.forEach {}
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, max: 256)
            try self.validate(self.connectorProfileName, name: "connectorProfileName", parent: name, pattern: "[\\w/!@#+=.-]+")
            try self.incrementalPullConfig?.validate(name: "\(name).incrementalPullConfig")
            try self.incrementalPullConfig?.forEach {}
            try self.sourceConnectorProperties.validate(name: "\(name).sourceConnectorProperties")
            try self.sourceConnectorProperties.forEach {}
        }

        private enum CodingKeys: String, CodingKey {
            case connectorProfileName = "ConnectorProfileName"
            case connectorType = "ConnectorType"
            case incrementalPullConfig = "IncrementalPullConfig"
            case sourceConnectorProperties = "SourceConnectorProperties"
        }
    }

    public struct TagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn"))
        ]

        /// The ARN of the resource that you're adding tags to.
        public let resourceArn: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]

        public init(resourceArn: String, tags: [String: String]) {
            self.resourceArn = resourceArn
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.resourceArn.forEach {}
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z0-9]{1,10}:profile")
            try self.tags.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case tags
        }
    }

    public struct TagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct Task: AWSEncodableShape {
        public let connectorOperator: ConnectorOperator?
        public let destinationField: String?
        public let sourceFields: [String]
        public let taskProperties: [OperatorPropertiesKeys: String]?
        public let taskType: TaskType

        public init(connectorOperator: ConnectorOperator? = nil, destinationField: String? = nil, sourceFields: [String], taskProperties: [OperatorPropertiesKeys: String]? = nil, taskType: TaskType) {
            self.connectorOperator = connectorOperator
            self.destinationField = destinationField
            self.sourceFields = sourceFields
            self.taskProperties = taskProperties
            self.taskType = taskType
        }

        public func validate(name: String) throws {
            try self.destinationField?.forEach {}
            try self.validate(self.destinationField, name: "destinationField", parent: name, max: 256)
            try self.validate(self.destinationField, name: "destinationField", parent: name, pattern: ".*")
            try self.sourceFields.forEach {
                try validate($0, name: "sourceFields[]", parent: name, max: 2048)
                try validate($0, name: "sourceFields[]", parent: name, pattern: ".*")
            }
            try self.sourceFields.forEach {}
            try self.taskProperties?.forEach {
                try validate($0.value, name: "taskProperties[\"\($0.key)\"]", parent: name, max: 2048)
                try validate($0.value, name: "taskProperties[\"\($0.key)\"]", parent: name, pattern: ".+")
            }
        }

        private enum CodingKeys: String, CodingKey {
            case connectorOperator = "ConnectorOperator"
            case destinationField = "DestinationField"
            case sourceFields = "SourceFields"
            case taskProperties = "TaskProperties"
            case taskType = "TaskType"
        }
    }

    public struct TriggerConfig: AWSEncodableShape {
        public let triggerProperties: TriggerProperties?
        public let triggerType: TriggerType

        public init(triggerProperties: TriggerProperties? = nil, triggerType: TriggerType) {
            self.triggerProperties = triggerProperties
            self.triggerType = triggerType
        }

        public func validate(name: String) throws {
            try self.triggerProperties?.validate(name: "\(name).triggerProperties")
            try self.triggerProperties?.forEach {}
        }

        private enum CodingKeys: String, CodingKey {
            case triggerProperties = "TriggerProperties"
            case triggerType = "TriggerType"
        }
    }

    public struct TriggerProperties: AWSEncodableShape {
        public let scheduled: ScheduledTriggerProperties?

        public init(scheduled: ScheduledTriggerProperties? = nil) {
            self.scheduled = scheduled
        }

        public func validate(name: String) throws {
            try self.scheduled?.validate(name: "\(name).scheduled")
            try self.scheduled?.forEach {}
        }

        private enum CodingKeys: String, CodingKey {
            case scheduled = "Scheduled"
        }
    }

    public struct UntagResourceRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "resourceArn", location: .uri(locationName: "resourceArn")),
            AWSMemberEncoding(label: "tagKeys", location: .querystring(locationName: "tagKeys"))
        ]

        /// The ARN of the resource from which you are removing tags.
        public let resourceArn: String
        /// The list of tag keys to remove from the resource.
        public let tagKeys: [String]

        public init(resourceArn: String, tagKeys: [String]) {
            self.resourceArn = resourceArn
            self.tagKeys = tagKeys
        }

        public func validate(name: String) throws {
            try self.resourceArn.forEach {}
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, max: 256)
            try self.validate(self.resourceArn, name: "resourceArn", parent: name, pattern: "^arn:[a-z0-9]{1,10}:profile")
            try self.tagKeys.forEach {
                try validate($0, name: "tagKeys[]", parent: name, max: 128)
                try validate($0, name: "tagKeys[]", parent: name, min: 1)
                try validate($0, name: "tagKeys[]", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
            }
            try self.tagKeys.forEach {}
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, max: 50)
            try self.validate(self.tagKeys, name: "tagKeys", parent: name, min: 1)
        }

        private enum CodingKeys: CodingKey {}
    }

    public struct UntagResourceResponse: AWSDecodableShape {
        public init() {}
    }

    public struct UpdateAddress: AWSEncodableShape {
        /// The first line of a customer address.
        public let address1: String?
        /// The second line of a customer address.
        public let address2: String?
        /// The third line of a customer address.
        public let address3: String?
        /// The fourth line of a customer address.
        public let address4: String?
        /// The city in which a customer lives.
        public let city: String?
        /// The country in which a customer lives.
        public let country: String?
        /// The county in which a customer lives.
        public let county: String?
        /// The postal code of a customer address.
        public let postalCode: String?
        /// The province in which a customer lives.
        public let province: String?
        /// The state in which a customer lives.
        public let state: String?

        public init(address1: String? = nil, address2: String? = nil, address3: String? = nil, address4: String? = nil, city: String? = nil, country: String? = nil, county: String? = nil, postalCode: String? = nil, province: String? = nil, state: String? = nil) {
            self.address1 = address1
            self.address2 = address2
            self.address3 = address3
            self.address4 = address4
            self.city = city
            self.country = country
            self.county = county
            self.postalCode = postalCode
            self.province = province
            self.state = state
        }

        public func validate(name: String) throws {
            try self.address1?.forEach {}
            try self.validate(self.address1, name: "address1", parent: name, max: 255)
            try self.validate(self.address1, name: "address1", parent: name, min: 0)
            try self.address2?.forEach {}
            try self.validate(self.address2, name: "address2", parent: name, max: 255)
            try self.validate(self.address2, name: "address2", parent: name, min: 0)
            try self.address3?.forEach {}
            try self.validate(self.address3, name: "address3", parent: name, max: 255)
            try self.validate(self.address3, name: "address3", parent: name, min: 0)
            try self.address4?.forEach {}
            try self.validate(self.address4, name: "address4", parent: name, max: 255)
            try self.validate(self.address4, name: "address4", parent: name, min: 0)
            try self.city?.forEach {}
            try self.validate(self.city, name: "city", parent: name, max: 255)
            try self.validate(self.city, name: "city", parent: name, min: 0)
            try self.country?.forEach {}
            try self.validate(self.country, name: "country", parent: name, max: 255)
            try self.validate(self.country, name: "country", parent: name, min: 0)
            try self.county?.forEach {}
            try self.validate(self.county, name: "county", parent: name, max: 255)
            try self.validate(self.county, name: "county", parent: name, min: 0)
            try self.postalCode?.forEach {}
            try self.validate(self.postalCode, name: "postalCode", parent: name, max: 255)
            try self.validate(self.postalCode, name: "postalCode", parent: name, min: 0)
            try self.province?.forEach {}
            try self.validate(self.province, name: "province", parent: name, max: 255)
            try self.validate(self.province, name: "province", parent: name, min: 0)
            try self.state?.forEach {}
            try self.validate(self.state, name: "state", parent: name, max: 255)
            try self.validate(self.state, name: "state", parent: name, min: 0)
        }

        private enum CodingKeys: String, CodingKey {
            case address1 = "Address1"
            case address2 = "Address2"
            case address3 = "Address3"
            case address4 = "Address4"
            case city = "City"
            case country = "Country"
            case county = "County"
            case postalCode = "PostalCode"
            case province = "Province"
            case state = "State"
        }
    }

    public struct UpdateDomainRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications. If specified as an empty string, it will clear any existing value. You must set up a policy on the DeadLetterQueue for the SendMessage operation to enable Amazon Connect Customer Profiles to send messages to the DeadLetterQueue.
        public let deadLetterQueueUrl: String?
        /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage. If specified as an empty string, it will clear any existing value.
        public let defaultEncryptionKey: String?
        /// The default number of days until the data within the domain expires.
        public let defaultExpirationDays: Int?
        /// The unique name for the domain.
        public let domainName: String
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(deadLetterQueueUrl: String? = nil, defaultEncryptionKey: String? = nil, defaultExpirationDays: Int? = nil, domainName: String, tags: [String: String]? = nil) {
            self.deadLetterQueueUrl = deadLetterQueueUrl
            self.defaultEncryptionKey = defaultEncryptionKey
            self.defaultExpirationDays = defaultExpirationDays
            self.domainName = domainName
            self.tags = tags
        }

        public func validate(name: String) throws {
            try self.deadLetterQueueUrl?.forEach {}
            try self.validate(self.deadLetterQueueUrl, name: "deadLetterQueueUrl", parent: name, max: 255)
            try self.validate(self.deadLetterQueueUrl, name: "deadLetterQueueUrl", parent: name, min: 0)
            try self.defaultEncryptionKey?.forEach {}
            try self.validate(self.defaultEncryptionKey, name: "defaultEncryptionKey", parent: name, max: 255)
            try self.validate(self.defaultEncryptionKey, name: "defaultEncryptionKey", parent: name, min: 0)
            try self.defaultExpirationDays?.forEach {}
            try self.validate(self.defaultExpirationDays, name: "defaultExpirationDays", parent: name, max: 1098)
            try self.validate(self.defaultExpirationDays, name: "defaultExpirationDays", parent: name, min: 1)
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.tags?.forEach {
                try validate($0.key, name: "tags.key", parent: name, max: 128)
                try validate($0.key, name: "tags.key", parent: name, min: 1)
                try validate($0.key, name: "tags.key", parent: name, pattern: "^(?!aws:)[a-zA-Z+-=._:/]+$")
                try validate($0.value, name: "tags[\"\($0.key)\"]", parent: name, max: 256)
            }
        }

        private enum CodingKeys: String, CodingKey {
            case deadLetterQueueUrl = "DeadLetterQueueUrl"
            case defaultEncryptionKey = "DefaultEncryptionKey"
            case defaultExpirationDays = "DefaultExpirationDays"
            case tags = "Tags"
        }
    }

    public struct UpdateDomainResponse: AWSDecodableShape {
        /// The timestamp of when the domain was created.
        public let createdAt: Date
        /// The URL of the SQS dead letter queue, which is used for reporting errors associated with ingesting data from third party applications.
        public let deadLetterQueueUrl: String?
        /// The default encryption key, which is an AWS managed key, is used when no specific type of encryption key is specified. It is used to encrypt all data before it is placed in permanent or semi-permanent storage.
        public let defaultEncryptionKey: String?
        /// The default number of days until the data within the domain expires.
        public let defaultExpirationDays: Int?
        /// The unique name for the domain.
        public let domainName: String
        /// The timestamp of when the domain was most recently edited.
        public let lastUpdatedAt: Date
        /// The tags used to organize, track, or control access for this resource.
        public let tags: [String: String]?

        public init(createdAt: Date, deadLetterQueueUrl: String? = nil, defaultEncryptionKey: String? = nil, defaultExpirationDays: Int? = nil, domainName: String, lastUpdatedAt: Date, tags: [String: String]? = nil) {
            self.createdAt = createdAt
            self.deadLetterQueueUrl = deadLetterQueueUrl
            self.defaultEncryptionKey = defaultEncryptionKey
            self.defaultExpirationDays = defaultExpirationDays
            self.domainName = domainName
            self.lastUpdatedAt = lastUpdatedAt
            self.tags = tags
        }

        private enum CodingKeys: String, CodingKey {
            case createdAt = "CreatedAt"
            case deadLetterQueueUrl = "DeadLetterQueueUrl"
            case defaultEncryptionKey = "DefaultEncryptionKey"
            case defaultExpirationDays = "DefaultExpirationDays"
            case domainName = "DomainName"
            case lastUpdatedAt = "LastUpdatedAt"
            case tags = "Tags"
        }
    }

    public struct UpdateProfileRequest: AWSEncodableShape {
        public static var _encoding = [
            AWSMemberEncoding(label: "domainName", location: .uri(locationName: "DomainName"))
        ]

        /// A unique account number that you have given to the customer.
        public let accountNumber: String?
        /// Any additional information relevant to the customer's profile.
        public let additionalInformation: String?
        /// A generic address associated with the customer that is not mailing, shipping, or billing.
        public let address: UpdateAddress?
        /// A key value pair of attributes of a customer profile.
        public let attributes: [String: String]?
        /// The customer’s billing address.
        public let billingAddress: UpdateAddress?
        /// The customer’s birth date.
        public let birthDate: String?
        /// The customer’s business email address.
        public let businessEmailAddress: String?
        /// The name of the customer’s business.
        public let businessName: String?
        /// The customer’s business phone number.
        public let businessPhoneNumber: String?
        /// The unique name of the domain.
        public let domainName: String
        /// The customer's email address, which has not been specified as a personal or business address.
        public let emailAddress: String?
        /// The customer’s first name.
        public let firstName: String?
        /// The gender with which the customer identifies.
        public let gender: Gender?
        /// The customer’s home phone number.
        public let homePhoneNumber: String?
        /// The customer’s last name.
        public let lastName: String?
        /// The customer’s mailing address.
        public let mailingAddress: UpdateAddress?
        /// The customer’s middle name.
        public let middleName: String?
        /// The customer’s mobile phone number.
        public let mobilePhoneNumber: String?
        /// The type of profile used to describe the customer.
        public let partyType: PartyType?
        /// The customer’s personal email address.
        public let personalEmailAddress: String?
        /// The customer's phone number, which has not been specified as a mobile, home, or business number.
        public let phoneNumber: String?
        /// The unique identifier of a customer profile.
        public let profileId: String
        /// The customer’s shipping address.
        public let shippingAddress: UpdateAddress?

        public init(accountNumber: String? = nil, additionalInformation: String? = nil, address: UpdateAddress? = nil, attributes: [String: String]? = nil, billingAddress: UpdateAddress? = nil, birthDate: String? = nil, businessEmailAddress: String? = nil, businessName: String? = nil, businessPhoneNumber: String? = nil, domainName: String, emailAddress: String? = nil, firstName: String? = nil, gender: Gender? = nil, homePhoneNumber: String? = nil, lastName: String? = nil, mailingAddress: UpdateAddress? = nil, middleName: String? = nil, mobilePhoneNumber: String? = nil, partyType: PartyType? = nil, personalEmailAddress: String? = nil, phoneNumber: String? = nil, profileId: String, shippingAddress: UpdateAddress? = nil) {
            self.accountNumber = accountNumber
            self.additionalInformation = additionalInformation
            self.address = address
            self.attributes = attributes
            self.billingAddress = billingAddress
            self.birthDate = birthDate
            self.businessEmailAddress = businessEmailAddress
            self.businessName = businessName
            self.businessPhoneNumber = businessPhoneNumber
            self.domainName = domainName
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.gender = gender
            self.homePhoneNumber = homePhoneNumber
            self.lastName = lastName
            self.mailingAddress = mailingAddress
            self.middleName = middleName
            self.mobilePhoneNumber = mobilePhoneNumber
            self.partyType = partyType
            self.personalEmailAddress = personalEmailAddress
            self.phoneNumber = phoneNumber
            self.profileId = profileId
            self.shippingAddress = shippingAddress
        }

        public func validate(name: String) throws {
            try self.accountNumber?.forEach {}
            try self.validate(self.accountNumber, name: "accountNumber", parent: name, max: 255)
            try self.validate(self.accountNumber, name: "accountNumber", parent: name, min: 0)
            try self.additionalInformation?.forEach {}
            try self.validate(self.additionalInformation, name: "additionalInformation", parent: name, max: 1000)
            try self.validate(self.additionalInformation, name: "additionalInformation", parent: name, min: 0)
            try self.address?.validate(name: "\(name).address")
            try self.address?.forEach {}
            try self.attributes?.forEach {
                try validate($0.key, name: "attributes.key", parent: name, max: 255)
                try validate($0.key, name: "attributes.key", parent: name, min: 1)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, max: 255)
                try validate($0.value, name: "attributes[\"\($0.key)\"]", parent: name, min: 0)
            }
            try self.billingAddress?.validate(name: "\(name).billingAddress")
            try self.billingAddress?.forEach {}
            try self.birthDate?.forEach {}
            try self.validate(self.birthDate, name: "birthDate", parent: name, max: 255)
            try self.validate(self.birthDate, name: "birthDate", parent: name, min: 0)
            try self.businessEmailAddress?.forEach {}
            try self.validate(self.businessEmailAddress, name: "businessEmailAddress", parent: name, max: 255)
            try self.validate(self.businessEmailAddress, name: "businessEmailAddress", parent: name, min: 0)
            try self.businessName?.forEach {}
            try self.validate(self.businessName, name: "businessName", parent: name, max: 255)
            try self.validate(self.businessName, name: "businessName", parent: name, min: 0)
            try self.businessPhoneNumber?.forEach {}
            try self.validate(self.businessPhoneNumber, name: "businessPhoneNumber", parent: name, max: 255)
            try self.validate(self.businessPhoneNumber, name: "businessPhoneNumber", parent: name, min: 0)
            try self.domainName.forEach {}
            try self.validate(self.domainName, name: "domainName", parent: name, max: 64)
            try self.validate(self.domainName, name: "domainName", parent: name, min: 1)
            try self.validate(self.domainName, name: "domainName", parent: name, pattern: "^[a-zA-Z0-9_-]+$")
            try self.emailAddress?.forEach {}
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, max: 255)
            try self.validate(self.emailAddress, name: "emailAddress", parent: name, min: 0)
            try self.firstName?.forEach {}
            try self.validate(self.firstName, name: "firstName", parent: name, max: 255)
            try self.validate(self.firstName, name: "firstName", parent: name, min: 0)
            try self.homePhoneNumber?.forEach {}
            try self.validate(self.homePhoneNumber, name: "homePhoneNumber", parent: name, max: 255)
            try self.validate(self.homePhoneNumber, name: "homePhoneNumber", parent: name, min: 0)
            try self.lastName?.forEach {}
            try self.validate(self.lastName, name: "lastName", parent: name, max: 255)
            try self.validate(self.lastName, name: "lastName", parent: name, min: 0)
            try self.mailingAddress?.validate(name: "\(name).mailingAddress")
            try self.mailingAddress?.forEach {}
            try self.middleName?.forEach {}
            try self.validate(self.middleName, name: "middleName", parent: name, max: 255)
            try self.validate(self.middleName, name: "middleName", parent: name, min: 0)
            try self.mobilePhoneNumber?.forEach {}
            try self.validate(self.mobilePhoneNumber, name: "mobilePhoneNumber", parent: name, max: 255)
            try self.validate(self.mobilePhoneNumber, name: "mobilePhoneNumber", parent: name, min: 0)
            try self.personalEmailAddress?.forEach {}
            try self.validate(self.personalEmailAddress, name: "personalEmailAddress", parent: name, max: 255)
            try self.validate(self.personalEmailAddress, name: "personalEmailAddress", parent: name, min: 0)
            try self.phoneNumber?.forEach {}
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, max: 255)
            try self.validate(self.phoneNumber, name: "phoneNumber", parent: name, min: 0)
            try self.profileId.forEach {}
            try self.validate(self.profileId, name: "profileId", parent: name, pattern: "[a-f0-9]{32}")
            try self.shippingAddress?.validate(name: "\(name).shippingAddress")
            try self.shippingAddress?.forEach {}
        }

        private enum CodingKeys: String, CodingKey {
            case accountNumber = "AccountNumber"
            case additionalInformation = "AdditionalInformation"
            case address = "Address"
            case attributes = "Attributes"
            case billingAddress = "BillingAddress"
            case birthDate = "BirthDate"
            case businessEmailAddress = "BusinessEmailAddress"
            case businessName = "BusinessName"
            case businessPhoneNumber = "BusinessPhoneNumber"
            case emailAddress = "EmailAddress"
            case firstName = "FirstName"
            case gender = "Gender"
            case homePhoneNumber = "HomePhoneNumber"
            case lastName = "LastName"
            case mailingAddress = "MailingAddress"
            case middleName = "MiddleName"
            case mobilePhoneNumber = "MobilePhoneNumber"
            case partyType = "PartyType"
            case personalEmailAddress = "PersonalEmailAddress"
            case phoneNumber = "PhoneNumber"
            case profileId = "ProfileId"
            case shippingAddress = "ShippingAddress"
        }
    }

    public struct UpdateProfileResponse: AWSDecodableShape {
        /// The unique identifier of a customer profile.
        public let profileId: String

        public init(profileId: String) {
            self.profileId = profileId
        }

        private enum CodingKeys: String, CodingKey {
            case profileId = "ProfileId"
        }
    }

    public struct ZendeskSourceProperties: AWSEncodableShape {
        public let object: String

        public init(object: String) {
            self.object = object
        }

        public func validate(name: String) throws {
            try self.object.forEach {}
            try self.validate(self.object, name: "object", parent: name, max: 512)
            try self.validate(self.object, name: "object", parent: name, pattern: "\\S+")
        }

        private enum CodingKeys: String, CodingKey {
            case object = "Object"
        }
    }
}
